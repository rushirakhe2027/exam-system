<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>ExamPro - {{ exam.title }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #e9f0fb;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* ENHANCED SECURITY: Disable text selection and copy/paste */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Prevent right-click context menu */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Allow text selection only in answer inputs */
        textarea, input[type="text"], input[type="radio"], input[type="checkbox"] {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }
        
        .header {
            background-color: #1a47a0;
            color: white;
            padding: 15px 0;
            position: relative;
            height: 76px;
            display: flex;
            align-items: center;
        }
        .exam-title {
            text-align: center;
            font-weight: 500;
            flex: 1;
            font-size: 1.5rem;
        }
        .exam-timer {
            font-size: 1.5rem;
            font-family: monospace;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 5px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            font-weight: bold;
            color: white;
        }
        .header-right {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .violation-counter {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        
        #violation-badge {
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 60px;
            padding: 8px 12px;
            border: 2px solid rgba(255,255,255,0.3);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        #violation-badge:hover {
            transform: scale(1.1);
        }
        .warning-counter small {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        .exam-logo {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5rem;
            font-weight: bold;
        }
        .sidebar {
            background-color: #1a47a0;
            color: white;
            padding: 20px;
            height: calc(100vh - 76px);
            position: relative;
        overflow-y: auto;
        }
        .camera-section h5 {
            color: white;
            margin-bottom: 15px;
            font-size: 1rem;
        }
        .camera-box {
            background-color: #000;
        width: 100%;
            height: 180px;
        margin-bottom: 20px;
            border-radius: 5px;
        overflow: hidden;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
    }
        .camera-feed {
        width: 100%;
        height: 100%;
    object-fit: cover;
}
        .camera-required {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6c757d;
            font-size: 0.9rem;
            text-align: center;
            width: 100%;
        }
        .camera-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #dc3545;
        }
        .status-indicator.active {
            background-color: #28a745;
        }
        
        /* ENHANCED FACE DETECTION DISPLAY */
        .face-detection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .face-status-display {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            z-index: 11;
        }
        
        .face-warning {
            color: #ff6b6b !important;
            font-weight: bold;
        }
        
        .face-normal {
            color: #51cf66 !important;
        }
        
        .questions-section h5 {
            color: white;
            margin-bottom: 15px;
            margin-top: 20px;
            font-size: 1rem;
        }
        .question-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 0;
        }
    .question-btn {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
    justify-content: center;
            background-color: #6c757d;
            color: white;
            border-radius: 6px;
        cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
    }
    .question-btn.active {
            background-color: #4285f4;
            box-shadow: 0 3px 6px rgba(66, 133, 244, 0.3);
            transform: translateY(-1px);
    }
    .question-btn.answered {
            background-color: #28a745;
            box-shadow: 0 3px 6px rgba(40, 167, 69, 0.3);
        }
    .question-btn.saved {
        background-color: #28a745 !important;
        box-shadow: 0 3px 6px rgba(40, 167, 69, 0.4) !important;
        border: 2px solid #20c997 !important;
    }
    .question-btn.saved::after {
        content: '‚úì';
        position: absolute;
        top: -5px;
        right: -5px;
        background: #20c997;
        color: white;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
        .question-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        .main-content {
            height: calc(100vh - 76px);
            overflow-y: auto;
            padding: 20px;
            background-color: #f0f5ff;
        }
        .main-content.expanded {
            padding-left: 40px;
        }
        .question-container {
            background-color: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            max-width: 900px;
        }
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }
        .question-number {
            background-color: #4285f4;
        color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 500;
        }
        .question-text {
            font-size: 1.1rem;
            margin-bottom: 25px;
            line-height: 1.6;
            color: #333;
}
        .option-item {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #fff;
    }
        .option-item:hover {
            background-color: #f8f9fa;
            border-color: #4285f4;
        }
        .option-item.selected {
            border-color: #4285f4;
            background-color: #e8f0fe;
        }
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        .exam-footer {
            padding: 10px;
    text-align: center;
            color: white;
            background-color: #1a47a0;
            font-size: 0.9rem;
            position: absolute;
            bottom: 0;
            width: calc(100% - 40px);
            margin: 0 20px;
            border-radius: 5px 5px 0 0;
    }
        
        /* Procrastination Warning Styles */
        .procrastination-warning {
            animation: slideInRight 0.3s ease-out;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-bottom: 10px;
        }
        
        .procrastination-warning.fade-out {
            animation: slideOutRight 0.3s ease-in;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        #warning-container {
            max-height: 70vh;
            overflow-y: auto;
        }
        
        #warning-container::-webkit-scrollbar {
            width: 6px;
        }
        
        #warning-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #warning-container::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }
    
        /* Proctor alert styles */
        .proctor-alert {
            position: fixed;
            top: 76px;
            right: 20px;
            width: 300px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.95);
            border-left: 4px solid #dc3545;
            border-radius: 4px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.3s ease-out;
            max-height: 400px;
            overflow-y: auto;
    }
        .alert-item {
            border-left: 4px solid #dc3545;
            padding: 10px 15px;
            margin-bottom: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            animation: fadeIn 0.5s;
        }
        .alert-item.neck-movement {
            border-left-color: #fd7e14;
}
        .alert-item.multiple-people {
            border-left-color: #dc3545;
}
        .alert-item.absence {
            border-left-color: #6610f2;
    }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        @keyframes pulse {
        0% { opacity: 1; }
            50% { opacity: 0.7; }
        100% { opacity: 1; }
    }
        .alert-pulse {
            animation: pulse 1s infinite;
}
        .toggle-sidebar-btn {
            background-color: #4285f4;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            margin-bottom: 20px;
}
        .question-counter {
            font-size: 0.95rem;
            color: #666;
            margin-left: 20px;
}
        .question-counter {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(0,123,255,0.3);
        }
        
        .sidebar-content {
            border-right: 3px solid #007bff;
        }
        
        .toggle-sidebar-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .toggle-sidebar-btn:hover {
            background: #0056b3;
            transform: translateX(-2px);
        }
        
        .question-btn.answered {
            background: #28a745 !important;
            color: white !important;
            border-color: #28a745 !important;
        }
        
        .question-btn.current {
            background: #007bff !important;
            color: white !important;
            border-color: #007bff !important;
        }
        
        .main-content {
            transition: margin-left 0.3s ease;
        }
        
        .option-item.selected {
            background: #e3f2fd !important;
            border-color: #007bff !important;
            color: #0056b3 !important;
        }
        
        .exam-footer {
            border-top: 3px solid #007bff;
        }
        
        /* SweetAlert Custom Styles */
        .swal2-warning-popup {
            background: linear-gradient(135deg, #fff, #f8f9fa) !important;
            border: 2px solid #dc3545 !important;
        }
        
        .swal2-large {
            width: 32em !important;
            max-width: 90% !important;
        }
        
        .swal2-warning-popup .swal2-title {
            color: #dc3545 !important;
        }
        
        .auto-submit-notification {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .results-summary {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .score-display {
            font-size: 1.5em;
            font-weight: bold;
            color: #007bff;
        }
        
        .evaluation-notice {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        /* Additional fixes for question navigation */
        .questions-section {
            margin-bottom: 20px;
        }
        
        .question-nav {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .question-nav::-webkit-scrollbar {
            width: 4px;
        }
        
        .question-nav::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .question-nav::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
</style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="exam-logo">ExamPro</div>
        <div class="exam-title">{{ exam.title }}</div>
        <div class="header-right">
            <div class="violation-counter" id="violationCounter">
                <span class="badge bg-success" id="violation-badge">0/20</span>
                <small>Violations</small>
            </div>
        <div class="exam-timer" id="examTimer">{{ exam.duration }}:00</div>
        </div>
    </div>
    
    <div class="container-fluid p-0">
        <div class="row g-0">
            <!-- Sidebar -->
            <div class="col-md-3 sidebar" id="sidebar">
                <div class="camera-section">
                    <h5><i class="fas fa-video me-2"></i>Face Detection Monitor</h5>
                    <div class="camera-box">
                        <video id="cameraFeed" class="camera-feed" autoplay muted playsinline style="display: none;"></video>
                        <canvas id="faceDetectionCanvas" class="face-detection-overlay"></canvas>
                        <div id="faceStatusDisplay" class="face-status-display">
                            <div>Faces: <span id="faceCount">0</span></div>
                            <div>Status: <span id="faceStatus">Initializing...</span></div>
                            <div>Pose: <span id="poseDirection">Unknown</span></div>
                        </div>
                        <div class="camera-required" id="cameraPlaceholder">
                        <div class="camera-icon">
                                <i class="fas fa-video-slash"></i>
                            </div>
                            <div>Camera Required</div>
                            <small>Face detection will start automatically</small>
                        </div>
                        <div class="status-indicator" id="cameraStatus"></div>
                    </div>
                </div>
                
                <div class="questions-section">
                    <h5>Questions</h5>
                    <div class="question-nav" id="questionNav">
                        {% for i in range(1, total_questions + 1) %}
                        <button class="question-btn" data-question="{{ i }}" onclick="navigateToQuestion({{ i }})">
                            {{ i }}
                        </button>
                        {% endfor %}
                    </div>
                </div>
                
                <div class="exam-footer">
                    Exam in progress
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-md-9 main-content" id="mainContent">
                <div class="mb-3 d-flex align-items-center">
                    <button class="toggle-sidebar-btn" id="toggleSidebarBtn">¬´ Hide Questions</button>
                    <span class="question-counter" id="questionCounter">Question 1 of {{ total_questions }}</span>
        </div>

                <form id="examForm" method="POST" action="{{ url_for('student.submit_exam', exam_id=exam.id) }}">
                    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                
                        {% for question in questions %}
                    <!-- DEBUG: Question {{ loop.index }} ID: {{ question._id or question.id }} -->
                    <div class="question-container" id="question-container-{{ loop.index }}" style="{% if loop.index != 1 %}display: none;{% endif %}">
                        <div class="question-header">
                            <div class="question-number">Question {{ loop.index }}</div>
                            <span class="badge bg-secondary">{{ question.marks }} marks</span>
                                </div>
                    
                        <div class="question-text">
                            {{ question.question_text }}
                        </div>
                    
                                {% if question.question_type == 'multiple_choice' %}
                        <div class="options-list">
                                        {% for option in question.options %}
                            <div class="option-item" onclick="selectOption(this, '{{ question._id or question.id }}', '{{ option }}')">
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="answer_{{ question._id or question.id }}" id="q{{ question._id or question.id }}_opt{{ loop.index0 }}" value="{{ option }}" 
                                           {% if saved_answers.get('answer_' + (question._id or question.id)|string) == option %}checked{% endif %}>
                                    <label class="form-check-label" for="q{{ question._id or question.id }}_opt{{ loop.index0 }}">
                                            {{ option }}
                                        </label>
                                </div>
                        </div>
                                        {% endfor %}
                                    </div>
                                {% else %}
                                    <div class="form-group">
                        <label for="answer_{{ question._id or question.id }}">Your Answer:</label>
                            <textarea class="form-control" name="answer_{{ question._id or question.id }}" id="answer_{{ question._id or question.id }}" rows="4" required>{{ saved_answers.get('answer_' + (question._id or question.id)|string, '') }}</textarea>
                        </div>
                        {% endif %}

                        <div class="navigation-buttons">
                            <button type="button" class="btn btn-outline-primary" id="prevBtn-{{ loop.index }}" onclick="navigateToQuestion({{ loop.index - 1 }})" {% if loop.index == 1 %}disabled{% endif %}>
                                ¬´ Previous
                            </button>
                            
                            {% if loop.index < total_questions %}
                            <button type="button" class="btn btn-success me-2" id="saveNextBtn-{{ loop.index }}" onclick="saveAndNext({{ loop.index }})">
                                <i class="fas fa-save me-1"></i> Save & Next
                            </button>
                            {% else %}
                            <!-- Save button for the last question -->
                            <button type="button" class="btn btn-success me-2" id="saveBtn-{{ loop.index }}" onclick="saveCurrentAnswer({{ loop.index }})">
                                <i class="fas fa-save me-1"></i> Save Answer
                            </button>
                            {% endif %}
                            
                            <button type="button" class="btn btn-primary" id="nextBtn-{{ loop.index }}" onclick="navigateToQuestion({{ loop.index + 1 }})" {% if loop.index == total_questions %}style="display: none;"{% endif %}>
                                Next ¬ª
                            </button>
                            {% if loop.index == total_questions %}
                            <button type="submit" class="btn btn-success btn-lg" id="submitExamBtn">
                                <i class="fas fa-paper-plane me-2"></i> Submit Exam
                            </button>
                            {% endif %}
                        </div>
                    </div>
                    {% endfor %}
                </form>
        </div>
    </div>
</div>

    <!-- Proctor Alert Container -->
    <div class="proctor-alert d-none" id="proctorAlert">
        <div class="d-flex justify-content-between align-items-center mb-2">
            <h5 class="mb-0">Proctor Alerts</h5>
            <button type="button" class="btn-close" onclick="closeProctorAlert()"></button>
        </div>
        <div id="alertPanel"></div>
</div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
<script>
// Global variables - define at the top for accessibility
const examId = '{{ exam.id }}';
const examFormat = '{{ exam.exam_format }}';
let currentQuestion = 1;
const totalQuestions = {{ total_questions }};
let examDuration = {{ exam.duration }};
let timeLeft = examDuration * 60;
let timerInterval;
let socket;
let cameraStream = null;

console.log('üéØ Exam initialized:', {
    examId: examId,
    examFormat: examFormat,
    totalQuestions: totalQuestions,
    duration: examDuration
});

document.addEventListener('DOMContentLoaded', function() {
    console.log('üìö Exam interface loading...');
    
    // DEBUGGING MODE ENABLED
    console.log('üîß ===============================================');
    console.log('üîß DEBUGGING MODE ENABLED');
    console.log('üîß F12 Developer Tools Access: ALLOWED');
    console.log('üîß Console Logging: ENABLED');
    console.log('üîß Detailed Error Reporting: ENABLED');
    console.log('üîß ===============================================');
    
    // Initialize timer
    initializeTimer();
    
    // Initialize camera
    initializeCamera();
    
    // Initialize proctoring
    initializeProctoring();
    
    // Initialize navigation
    initializeNavigation();

    // Initialize form submission
    initializeFormSubmission();
    
    updateQuestionDisplay();
    
    // Initialize auto-save for answers
    initializeAutoSave();
    
    // Mark existing saved answers as green on page load
    markAnsweredQuestions();
    
    // Clean initialization without debugging
    
    // SIMPLE TEST: Add a test after 3 seconds to verify green styling works
    setTimeout(() => {
        console.log('üß™ TESTING: Manually marking question 1 as saved');
        markQuestionAsSaved(1);
        showSaveConfirmation(1);
    }, 3000);
    
    // DEBUGGING: Add manual test buttons for green checkmarks
    if (window.location.search.includes('debug=true')) {
        setTimeout(() => {
            const debugPanel = document.createElement('div');
            debugPanel.style.cssText = `
                position: fixed;
                top: 200px;
                right: 20px;
                background: #fff;
                border: 2px solid #007bff;
                padding: 15px;
                border-radius: 8px;
                z-index: 9999;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            `;
            debugPanel.innerHTML = `
                <h6>Debug Panel</h6>
                <button onclick="markQuestionAsSaved(1); showSaveConfirmation(1);" class="btn btn-sm btn-success mb-2">Mark Q1 Green</button><br>
                <button onclick="markQuestionAsSaved(2); showSaveConfirmation(2);" class="btn btn-sm btn-success mb-2">Mark Q2 Green</button><br>
                <button onclick="console.log('Question buttons:', document.querySelectorAll('[data-question]'));" class="btn btn-sm btn-info mb-2">Log Buttons</button><br>
                <button onclick="debugPanel.remove();" class="btn btn-sm btn-danger">Close</button>
            `;
            document.body.appendChild(debugPanel);
        }, 5000);
    }
});
        
        function initializeTimer() {
            const timerElement = document.getElementById('examTimer');
            
            if (!timerElement) {
                console.error('‚ùå Timer element not found!');
                return;
            }
            
            console.log('‚è∞ Initializing timer with duration:', examDuration, 'minutes');
            
            // Load saved timer state from localStorage
            const examStateKey = `exam_${examId}_state`;
            const savedState = localStorage.getItem(examStateKey);
            
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    timeLeft = state.timeLeft || timeLeft;
                    console.log(`‚è∞ Timer restored from saved state: ${timeLeft} seconds remaining`);
                } catch (e) {
                    console.warn('‚ö†Ô∏è Failed to parse saved timer state:', e);
                }
            }

            function updateTimer() {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const timeDisplay = minutes.toString().padStart(2, '0') + ':' + 
                                  seconds.toString().padStart(2, '0');
                
                timerElement.textContent = timeDisplay;
                console.log('‚è∞ Timer updated:', timeDisplay);
    
                if (timeLeft <= 300) { // 5 minutes remaining
                    timerElement.style.color = '#dc3545';
                    if (timeLeft === 300) {
                        showAlert('warning', '5 minutes remaining!');
                    }
                }
                
                // Save timer state every 10 seconds
                if (timeLeft % 10 === 0) {
                    saveExamState();
                }
                
                if (timeLeft <= 0) {
                    console.log('‚è∞ Time up! Auto-submitting exam...');
                    clearInterval(timerInterval);
                    submitExam();
                } else {
                    timeLeft--;
                }
            }
            
            // Start the timer immediately
            updateTimer();
            timerInterval = setInterval(updateTimer, 1000);
            console.log('‚úÖ Timer started successfully');
        }
        
        // Save exam state to localStorage
        function saveExamState() {
            const examStateKey = `exam_${examId}_state`;
            const state = {
                timeLeft: timeLeft,
                warningCount: window.procrastinationDetector ? window.procrastinationDetector.warningCount : 0,
                timestamp: Date.now()
            };
            localStorage.setItem(examStateKey, JSON.stringify(state));
        }
        
        // Load exam state from localStorage
        function loadExamState() {
            const examStateKey = `exam_${examId}_state`;
            const savedState = localStorage.getItem(examStateKey);
            
            if (savedState) {
                const state = JSON.parse(savedState);
                const timeDiff = (Date.now() - state.timestamp) / 1000; // seconds
                
                // Only restore if less than 5 minutes have passed (to prevent cheating)
                if (timeDiff < 300) {
                    return state;
                }
            }
            return null;
        }
        
        // Clear exam state when exam is submitted
        function clearExamState() {
            const examStateKey = `exam_${examId}_state`;
            localStorage.removeItem(examStateKey);
        }
        
        function initializeCamera() {
            const video = document.getElementById('cameraFeed');
            const placeholder = document.getElementById('cameraPlaceholder');
            const status = document.getElementById('cameraStatus');
            
            console.log('üé• Initializing camera for exam...');
            
            // Add timeout to prevent hanging
            const cameraTimeout = setTimeout(() => {
                console.warn('‚ö†Ô∏è Camera initialization timeout - continuing without camera');
                placeholder.innerHTML = `
                    <div class="camera-icon">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    Camera timeout - continuing exam
                `;
                status.classList.remove('active');
            }, 10000); // 10 second timeout
            
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: 'user'
                } 
            })
                .then(function(stream) {
                    clearTimeout(cameraTimeout);
                    console.log('‚úÖ Camera access granted');
                    
                    cameraStream = stream;
                    video.srcObject = stream;
                    video.style.display = 'block';
                    placeholder.style.display = 'none';
                    status.classList.add('active');
                    
                    // Wait for video to be ready before starting monitoring
                    video.addEventListener('loadedmetadata', () => {
                        console.log('üìπ Camera feed ready, starting monitoring...');
                        // Let the procrastination detector handle frame capture
                        // No need to start duplicate frame capture here
                    });
                })
                .catch(function(err) {
                    clearTimeout(cameraTimeout);
                    console.error('‚ùå Camera access denied:', err);
                    
                    // Show user-friendly error message
                    placeholder.innerHTML = `
                        <div class="camera-icon">
                            <i class="fas fa-video-slash"></i>
                        </div>
                        <div class="text-center">
                            <small>Camera access denied</small><br>
                            <small class="text-muted">Exam will continue with limited monitoring</small>
                        </div>
                    `;
                    status.classList.remove('active');
                    
                    // Show alert to user about camera issues
                    setTimeout(() => {
                        showAlert('warning', 'Camera access denied. Please enable camera permissions for full proctoring. The exam will continue with limited monitoring.');
                    }, 2000);
                });
        }
        
        function updateWarningCountDisplay(warningCount) {
            // OLD WARNING DISPLAY SYSTEM DISABLED - Now handled by ProcrastinationDetector
            // This was creating duplicate warning displays
            console.log('Warning count update handled by ProcrastinationDetector:', warningCount);
            
            /* DISABLED OLD WARNING DISPLAY - CAUSING DUPLICATES
            // Create or update warning count display
            let warningDisplay = document.getElementById('warning-count-display');
            if (!warningDisplay) {
                warningDisplay = document.createElement('div');
                warningDisplay.id = 'warning-count-display';
                warningDisplay.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #dc3545;
                    color: white;
                    padding: 10px 15px;
                    border-radius: 5px;
                    font-weight: bold;
                    z-index: 9999;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(warningDisplay);
                }
            
            warningDisplay.textContent = `Warnings: ${warningCount}/20`;
            
            // Change color based on warning level
            if (warningCount >= 16) {
                warningDisplay.style.backgroundColor = '#dc3545'; // Red
            } else if (warningCount >= 10) {
                warningDisplay.style.backgroundColor = '#ffc107'; // Yellow
            } else {
                warningDisplay.style.backgroundColor = '#28a745'; // Green
            }
            END OF DISABLED OLD WARNING DISPLAY */
        }
        
        function handleAutoSubmit(data) {
            // Stop camera and clear intervals
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            clearInterval(timerInterval);
            
            Swal.fire({
                icon: 'warning',
                title: 'Exam Auto-Submitted!',
                html: `
                    <div style="text-align: center;">
                        <p><strong>{{ exam.title }}</strong></p>
                        <p style="color: #dc3545; font-weight: bold;">
                            Maximum warnings exceeded (${data.warning_count}/20)
                        </p>
                        <p>${data.message}</p>
                    </div>
                `,
                showCancelButton: false,
                confirmButtonText: 'View Results',
                allowOutsideClick: false,
                allowEscapeKey: false
            }).then(() => {
                if (data.submission_id) {
                    window.location.href = `/student/submission/${data.submission_id}`;
                } else {
                    window.location.href = '/student/dashboard';
                }
            });
        }
        
        function initializeProctoring() {
            // Connect to WebSocket for real-time alerts
            try {
                socket = io();
                
                socket.on('proctor_alert', function(data) {
                    if (data.warnings && data.warnings.length > 0) {
                        showProctorAlerts(data.warnings.map(w => w.message));
                    }
                });
            } catch (e) {
                console.log('WebSocket not available:', e);
            }
        }
        
        function showProctorAlerts(alerts) {
            const alertPanel = document.getElementById('alertPanel');
            const proctorAlert = document.getElementById('proctorAlert');
            
            proctorAlert.classList.remove('d-none');
            
            alerts.forEach(alertMessage => {
                const alertItem = document.createElement('div');
                alertItem.className = 'alert-item alert-pulse';
                alertItem.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <strong>${alertMessage}</strong>
                        <span class="badge bg-danger">Warning</span>
                    </div>
                    <small class="text-muted">${new Date().toLocaleTimeString()}</small>
                `;
                
                alertPanel.insertBefore(alertItem, alertPanel.firstChild);
        
                // Remove pulse effect after 5 seconds
                setTimeout(() => {
                    alertItem.classList.remove('alert-pulse');
                }, 5000);
                
                // Limit number of alerts
                if (alertPanel.children.length > 5) {
                    alertPanel.removeChild(alertPanel.lastChild);
    }
            });
            
            // Play alert sound
            playAlertSound();
        }
        
        function playAlertSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 800;
                gainNode.gain.value = 0.2;
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                setTimeout(() => oscillator.stop(), 300);
            } catch (e) {
                console.log('Audio alert failed:', e);
            } 
        }
        
        function initializeNavigation() {
            const toggleBtn = document.getElementById('toggleSidebarBtn');
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            
            toggleBtn.addEventListener('click', function() {
                if (sidebar.style.display === 'none') {
                    sidebar.style.display = 'block';
                    mainContent.classList.remove('col-md-12', 'expanded');
                    mainContent.classList.add('col-md-9');
                    toggleBtn.textContent = '¬´ Hide Questions';
                } else {
                    sidebar.style.display = 'none';
                    mainContent.classList.remove('col-md-9');
                    mainContent.classList.add('col-md-12', 'expanded');
                    toggleBtn.textContent = 'Show Questions ¬ª';
                }
            });
        }
        
        function navigateToQuestion(questionNumber) {
            if (questionNumber < 1 || questionNumber > totalQuestions) return;
            
            // Hide current question
            document.getElementById(`question-container-${currentQuestion}`).style.display = 'none';
            
            // Show new question
            document.getElementById(`question-container-${questionNumber}`).style.display = 'block';
            
            // Update current question
            currentQuestion = questionNumber;
            
            updateQuestionDisplay();
        }
        
        function updateQuestionDisplay() {
            // Update question counter
            document.getElementById('questionCounter').textContent = 
                `Question ${currentQuestion} of ${totalQuestions}`;
            
            // Update question nav buttons
            const questionBtns = document.querySelectorAll('.question-btn');
            questionBtns.forEach((btn, index) => {
                btn.classList.toggle('active', index + 1 === currentQuestion);
            });
        }
        
        function selectOption(element, questionId, optionValue) {
            // Select the radio button
            const radioBtn = element.querySelector('input[type="radio"]');
            radioBtn.checked = true;

            // Update visual selection
            const options = element.parentNode.querySelectorAll('.option-item');
            options.forEach(option => option.classList.remove('selected'));
            element.classList.add('selected');
            
            // Mark question as answered
            const questionBtn = document.querySelector(`[data-question="${currentQuestion}"]`);
            if (questionBtn) {
                questionBtn.classList.add('answered');
            }
        }
        
        function initializeFormSubmission() {
            const form = document.getElementById('examForm');
            const submitBtn = document.getElementById('submitExamBtn');
            
            console.log('üîß Initializing form submission...');
            console.log('Form found:', !!form);
            console.log('Submit button found:', !!submitBtn);
            
            if (submitBtn) {
                // Remove any existing event listeners
                submitBtn.removeEventListener('click', handleSubmitClick);
                
                // Add new event listener
                submitBtn.addEventListener('click', handleSubmitClick);
                console.log('‚úÖ Submit button event listener added');
            }
            
            // Also handle form submission directly
            if (form) {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    console.log('üìù Form submit event triggered');
                    handleFormSubmission();
                });
                console.log('‚úÖ Form submit event listener added');
            }
        }
        
        function handleSubmitClick(e) {
            e.preventDefault();
            console.log('üñ±Ô∏è Submit button clicked');
                    
                    Swal.fire({
                        title: 'Submit Exam?',
                        text: 'Are you sure you want to submit your exam? This action cannot be undone.',
                        icon: 'warning',
                        showCancelButton: true,
                        confirmButtonText: 'Yes, submit',
                        cancelButtonText: 'No, review answers'
                    }).then(function(result) {
                        if (result.isConfirmed) {
                    console.log('‚úÖ User confirmed submission');
                    handleFormSubmission();
                } else {
                    console.log('‚ùå User cancelled submission');
                }
            });
        }
        
        function handleFormSubmission() {
            console.log('üöÄ Starting form submission process...');
            
            // Validate that form exists and has answers
            const form = document.getElementById('examForm');
            if (!form) {
                console.error('‚ùå Exam form not found');
                showAlert('error', 'Unable to find exam form. Please refresh and try again.');
                return;
            }
            
            // Check if we have any answers before submitting
            const formData = new FormData(form);
            let hasAnswers = false;
            for (let [key, value] of formData.entries()) {
                if (key.startsWith('answer_') && value && value.trim()) {
                    hasAnswers = true;
                    break;
                }
            }
            
            if (!hasAnswers) {
                console.warn('‚ö†Ô∏è No answers found in form');
                showAlert('warning', 'Please answer at least one question before submitting.');
                return;
            }
            
            console.log(`üìù Found answers in form, proceeding with submission`);
            
            // Try AJAX submission first
            try {
                submitExam();
            } catch (error) {
                console.error('‚ùå AJAX submission failed, trying fallback:', error);
                
                // Fallback to regular form submission
                if (form) {
                    console.log('üîÑ Using fallback form submission');
                    form.submit();
                } else {
                    console.error('‚ùå No form found for fallback submission');
                    showAlert('error', 'Unable to submit exam. Please refresh and try again.');
                }
            }
        }
        
        function submitExam() {
            console.log('üìù Submitting exam...');
            
            // Clear saved state when submitting
            clearExamState();
            
            // STEP 1: Try to get answers from session storage first (from auto-save)
            console.log('üîç Checking session storage for saved answers...');
            const sessionAnswers = {};
            
            // Try to get answers from the session via AJAX call
            fetch('/student/exam/{{ exam.id }}/get-session-answers', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(sessionData => {
                console.log('üìã Session answers retrieved:', sessionData);
                
                // STEP 2: Collect answers from form fields as backup
                const formAnswers = {};
                const form = document.getElementById('examForm');
                
                console.log('üîç Starting form answer collection...');
                console.log('üìã Form element:', form);
                
                // Get all form inputs
                const inputs = form.querySelectorAll('input[name^="answer_"], textarea[name^="answer_"], select[name^="answer_"]');
                console.log(`üìù Found ${inputs.length} input elements`);
                
                inputs.forEach((input, index) => {
                    const questionId = input.name.replace('answer_', '');
                    console.log(`üìÑ Processing input ${index + 1}: ${input.name} (ID: ${questionId}, Type: ${input.type}, Value: "${input.value}")`);
                    
                    // Debug: Check if questionId is empty
                    if (!questionId || questionId.trim() === '') {
                        console.warn(`‚ö†Ô∏è Empty question ID for input: ${input.name}`);
                        return; // Skip empty question IDs
                    }
                    
                    if (input.type === 'radio') {
                        if (input.checked) {
                            formAnswers[questionId] = input.value;
                            console.log(`‚úÖ Radio answer saved: ${questionId} = ${input.value}`);
                        }
                    } else if (input.type === 'checkbox') {
                        if (input.checked) {
                            if (!formAnswers[questionId]) {
                                formAnswers[questionId] = [];
                            }
                            formAnswers[questionId].push(input.value);
                            console.log(`‚úÖ Checkbox answer saved: ${questionId} = ${input.value}`);
                        }
                    } else {
                        // textarea, text, etc. - SAVE ALL ANSWERS, EVEN EMPTY ONES
                        formAnswers[questionId] = input.value ? input.value.trim() : '';
                        console.log(`‚úÖ Text answer saved: ${questionId} = "${formAnswers[questionId]}"`);
                    }
                });
                
                // STEP 3: Clean session answers and merge (remove answer_ prefix)
                const cleanedSessionAnswers = {};
                if (sessionData.answers) {
                    Object.keys(sessionData.answers).forEach(key => {
                        const cleanKey = key.startsWith('answer_') ? key.replace('answer_', '') : key;
                        cleanedSessionAnswers[cleanKey] = sessionData.answers[key];
                    });
                }
                
                // Merge form answers with cleaned session answers (session takes priority)
                const finalAnswers = { ...formAnswers, ...cleanedSessionAnswers };
                
                console.log('üìã Form answers collected:', formAnswers);
                console.log('üìã Session answers:', sessionData.answers);
                console.log('üìã Cleaned session answers:', cleanedSessionAnswers);
                console.log('üìã Final merged answers:', finalAnswers);
                console.log(`üìä Total answers collected: ${Object.keys(finalAnswers).length}`);
                
                // STEP 4: Submit the exam
                submitExamWithAnswers(finalAnswers);
            })
            .catch(error => {
                console.error('‚ùå Error getting session answers, using form only:', error);
                
                // Fallback: collect from form only (no duplicates)
                const answers = {};
                const form = document.getElementById('examForm');
                const inputs = form.querySelectorAll('input[name^="answer_"], textarea[name^="answer_"], select[name^="answer_"]');
                
                inputs.forEach((input, index) => {
                    const questionId = input.name.replace('answer_', '');
                    if (questionId && questionId.trim() !== '') {
                        if (input.type === 'radio' && input.checked) {
                            answers[questionId] = input.value;
                        } else if (input.type === 'checkbox' && input.checked) {
                            if (!answers[questionId]) answers[questionId] = [];
                            answers[questionId].push(input.value);
                        } else if (input.type !== 'radio' && input.type !== 'checkbox') {
                            answers[questionId] = input.value ? input.value.trim() : '';
                        }
                    }
                });
                
                console.log('üìã Fallback form answers (clean):', answers);
                submitExamWithAnswers(answers);
            });
        }
        
        function submitExamWithAnswers(answers) {
            console.log('üöÄ Submitting exam with answers:', answers);
            
            // Send as JSON data (backend expects JSON)
            fetch('/student/exam/{{ exam.id }}/submit', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    answers: answers
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('üì§ Submit response:', data);
                
                if (data.success) {
                    // Clear timer
                    if (timerInterval) {
                        clearInterval(timerInterval);
                    }
                    
                    // Stop procrastination detector
                    if (window.procrastinationDetector) {
                        window.procrastinationDetector.stop();
                    }
                    
                    // Clear any remaining state
                    clearExamState();
                    
                    console.log('‚úÖ Exam submitted successfully');
                    
                    // Show success message and redirect based on exam type or provided redirect URL
                    if (data.redirect_url) {
                        // Use the redirect URL provided by the server
                        console.log(`üîó Redirecting to: ${data.redirect_url}`);
                        
                        if (data.is_objective && data.is_graded) {
                            // For objective exams, show detailed results popup
                            showObjectiveResultsPopup(data);
                        } else {
                            // For subjective exams or direct redirects
                            console.log('üìù Showing subjective exam confirmation');
                            Swal.fire({
                                icon: 'success',
                                title: 'Exam Submitted Successfully!',
                                html: `
                                    <div class="text-center">
                                        <p class="mb-3">${data.message}</p>
                                        <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0;">
                                            <h6 class="text-warning mb-2">
                                                <i class="fas fa-clock"></i> Awaiting Teacher Evaluation
                                            </h6>
                                            <p class="mb-0 small text-muted">
                                                Your answers have been sent to the teacher for evaluation. 
                                                You will be notified once grading is complete.
                                            </p>
                                        </div>
                                        <p class="text-muted small">
                                            You will receive your results once the teacher completes the evaluation.
                                        </p>
                                    </div>
                                `,
                                showConfirmButton: true,
                                confirmButtonText: 'Return to Dashboard',
                                allowOutsideClick: false,
                                allowEscapeKey: false,
                                customClass: {
                                    popup: 'swal2-large'
                                }
                            }).then(() => {
                                // Redirect to provided URL (should be dashboard for subjective)
                                window.location.href = data.redirect_url;
                            });
                        }
                    } else {
                        // Fallback redirect if no redirect_url provided
                        console.log('‚ö†Ô∏è No redirect URL provided, using default dashboard redirect');
                        window.location.href = '/student/dashboard';
                    }
                } else {
                    console.error('‚ùå Submission failed:', data.error);
                    showAlert('error', data.error || 'Failed to submit exam');
                }
            })
            .catch(error => {
                console.error('üí• Submit error:', error);
                showAlert('error', 'An error occurred while submitting the exam. Please try again.');
            });
        }
        
        function showObjectiveResultsPopup(data) {
            // Create detailed answer comparison HTML
            let answersHtml = '';
            if (data.answer_details && data.answer_details.length > 0) {
                answersHtml = `
                    <div class="mt-4">
                        <h6 class="mb-3">üìù Question-wise Results:</h6>
                        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px;">
                `;
                
                data.answer_details.forEach(answer => {
                    const statusIcon = answer.is_correct ? '‚úÖ' : '‚ùå';
                    const statusColor = answer.is_correct ? '#28a745' : '#dc3545';
                    
                    answersHtml += `
                        <div class="mb-3 p-3" style="border: 1px solid #f0f0f0; border-radius: 6px; background: ${answer.is_correct ? '#f8fff8' : '#fff8f8'};">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <strong>Q${answer.question_number}: ${statusIcon}</strong>
                                <span style="color: ${statusColor}; font-weight: bold;">${answer.awarded_marks}/${answer.marks} marks</span>
                            </div>
                            <div style="font-size: 0.9rem;">
                                <div class="mb-2"><strong>Question:</strong> ${answer.question_text}</div>
                                <div class="mb-1"><strong>Your Answer:</strong> <span style="color: #666;">${answer.student_answer || 'Not answered'}</span></div>
                                <div><strong>Correct Answer:</strong> <span style="color: #28a745;">${answer.correct_answer}</span></div>
                            </div>
                        </div>
                    `;
                });
                
                answersHtml += '</div></div>';
            }
            
            // Show comprehensive results popup
            Swal.fire({
                icon: data.pass_fail === 'PASS' ? 'success' : 'error',
                title: 'üìä Exam Results',
                html: `
                    <div class="text-center">
                        <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 25px; border-radius: 12px; margin: 20px 0; border: 2px solid ${data.grade_color};">
                            <div class="row mb-4">
                                <div class="col-4">
                                    <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h3 style="color: ${data.grade_color}; margin: 0; font-weight: bold;">${data.grade}</h3>
                                        <small class="text-muted">Grade</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h3 style="color: ${data.grade_color}; margin: 0; font-weight: bold;">${data.percentage?.toFixed(1) || 0}%</h3>
                                        <small class="text-muted">Percentage</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h3 style="color: ${data.grade_color}; margin: 0; font-weight: bold;">${data.score}/${data.total_marks}</h3>
                                        <small class="text-muted">Score</small>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-6">
                                    <div style="background: white; padding: 12px; border-radius: 6px;">
                                        <strong>Result:</strong><br>
                                        <span class="badge" style="background-color: ${data.grade_color}; font-size: 0.9rem; padding: 6px 12px;">${data.pass_fail}</span>
                                    </div>
                                </div>
                                <div class="col-6">
                                    <div style="background: white; padding: 12px; border-radius: 6px;">
                                        <strong>Violations:</strong><br>
                                        <span class="badge ${data.violation_count > 10 ? 'bg-danger' : data.violation_count > 5 ? 'bg-warning' : 'bg-success'}">${data.violation_count} warnings</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 15px;">
                                <h6 class="mb-2">üìà Grade Scale:</h6>
                                <div class="d-flex justify-content-around text-center" style="font-size: 0.85rem;">
                                    <div><span style="color: #dc3545;">F</span><br><small>0-34%</small></div>
                                    <div><span style="color: #ffc107;">B</span><br><small>35-69%</small></div>
                                    <div><span style="color: #28a745;">A</span><br><small>70-100%</small></div>
                                </div>
                            </div>
                        </div>
                        
                        ${answersHtml}
                    </div>
                `,
                showCancelButton: true,
                confirmButtonText: 'üìã View Full Results',
                cancelButtonText: 'üè† Go to Dashboard',
                allowOutsideClick: false,
                allowEscapeKey: false,
                customClass: {
                    popup: 'swal2-large',
                    htmlContainer: 'text-start'
                },
                width: '90%',
                maxWidth: '800px'
            }).then((result) => {
                if (result.isConfirmed) {
                    // Go to detailed results page
                    window.location.href = data.redirect_url;
                } else {
                    // Go to dashboard
                    window.location.href = '/student/dashboard';
                }
            });
        }

        function showObjectiveResultsPopup(data) {
            // Create detailed answer comparison HTML
            let answersHtml = '';
            if (data.answer_details && data.answer_details.length > 0) {
                answersHtml = `
                    <div class="mt-4">
                        <h6 class="mb-3">üìù Question-wise Results:</h6>
                        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px;">
                `;
                
                data.answer_details.forEach(answer => {
                    const statusIcon = answer.is_correct ? '‚úÖ' : '‚ùå';
                    const statusColor = answer.is_correct ? '#28a745' : '#dc3545';
                    
                    answersHtml += `
                        <div class="mb-3 p-3" style="border: 1px solid #f0f0f0; border-radius: 6px; background: ${answer.is_correct ? '#f8fff8' : '#fff8f8'};">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <strong>Q${answer.question_number}: ${statusIcon}</strong>
                                <span style="color: ${statusColor}; font-weight: bold;">${answer.awarded_marks}/${answer.marks} marks</span>
                            </div>
                            <div style="font-size: 0.9rem;">
                                <div class="mb-2"><strong>Question:</strong> ${answer.question_text}</div>
                                <div class="mb-1"><strong>Your Answer:</strong> <span style="color: #666;">${answer.student_answer || 'Not answered'}</span></div>
                                <div><strong>Correct Answer:</strong> <span style="color: #28a745;">${answer.correct_answer}</span></div>
                            </div>
                        </div>
                    `;
                });
                
                answersHtml += '</div></div>';
            }
            
            // Show comprehensive results popup
            Swal.fire({
                icon: data.pass_fail === 'PASS' ? 'success' : 'error',
                title: 'üìä Exam Results',
                html: `
                    <div class="text-center">
                        <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 25px; border-radius: 12px; margin: 20px 0; border: 2px solid ${data.grade_color};">
                            <div class="row mb-4">
                                <div class="col-4">
                                    <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h3 style="color: ${data.grade_color}; margin: 0; font-weight: bold;">${data.grade}</h3>
                                        <small class="text-muted">Grade</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h3 style="color: ${data.grade_color}; margin: 0; font-weight: bold;">${data.percentage?.toFixed(1) || 0}%</h3>
                                        <small class="text-muted">Percentage</small>
                                    </div>
                                </div>
                                <div class="col-4">
                                    <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                        <h3 style="color: ${data.grade_color}; margin: 0; font-weight: bold;">${data.score}/${data.total_marks}</h3>
                                        <small class="text-muted">Score</small>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-6">
                                    <div style="background: white; padding: 12px; border-radius: 6px;">
                                        <strong>Result:</strong><br>
                                        <span class="badge" style="background-color: ${data.grade_color}; font-size: 0.9rem; padding: 6px 12px;">${data.pass_fail}</span>
                                    </div>
                                </div>
                                <div class="col-6">
                                    <div style="background: white; padding: 12px; border-radius: 6px;">
                                        <strong>Violations:</strong><br>
                                        <span class="badge ${data.violation_count > 10 ? 'bg-danger' : data.violation_count > 5 ? 'bg-warning' : 'bg-success'}">${data.violation_count} warnings</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div style="background: white; padding: 15px; border-radius: 8px; margin-top: 15px;">
                                <h6 class="mb-2">üìà Grade Scale:</h6>
                                <div class="d-flex justify-content-around text-center" style="font-size: 0.85rem;">
                                    <div><span style="color: #dc3545;">F</span><br><small>0-34%</small></div>
                                    <div><span style="color: #ffc107;">B</span><br><small>35-69%</small></div>
                                    <div><span style="color: #28a745;">A</span><br><small>70-100%</small></div>
                                </div>
                            </div>
                        </div>
                        
                        ${answersHtml}
                    </div>
                `,
                showCancelButton: true,
                confirmButtonText: 'üìã View Full Results',
                cancelButtonText: 'üè† Go to Dashboard',
                allowOutsideClick: false,
                allowEscapeKey: false,
                customClass: {
                    popup: 'swal2-large',
                    htmlContainer: 'text-start'
                },
                width: '90%',
                maxWidth: '800px'
            }).then((result) => {
                if (result.isConfirmed) {
                    // Go to detailed results page
                    window.location.href = data.redirect_url;
                } else {
                    // Go to dashboard
                    window.location.href = '/student/dashboard';
                }
            });
        }
        
        function showAlert(type, message) {
            Swal.fire({
                toast: true,
                icon: type,
                title: message,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000,
                timerProgressBar: true
            });
        }
        
        function closeProctorAlert() {
            document.getElementById('proctorAlert').classList.add('d-none');
    }
        
        // Prevent navigation away from page
        window.addEventListener('beforeunload', function(e) {
            if (timeLeft > 0) {
                e.preventDefault();
                e.returnValue = '';
}
        });

        // ====================================
        // ENHANCED FACE DETECTION & SECURITY SYSTEM
        // ====================================
        
        class EnhancedProctoringSystem {
            constructor() {
                this.faceDetection = null;
                this.faceMesh = null;
                this.camera = null;
                this.videoElement = null;
                this.canvasElement = null;
                this.canvasCtx = null;
                
                // State tracking
                this.currentFaceCount = 0;
                this.currentPoseDirection = 'unknown';
                this.cameraBlocked = false;
                this.isInitialized = false;
                
                // Pose history for stability (like your Python code)
                this.poseHistory = [];
                this.maxPoseHistory = 5;
                
                // Pose thresholds (only left/right detection as requested)
                this.poseThresholds = {
                    yawLeft: -20,    // Looking left
                    yawRight: 20     // Looking right
                };
                
                // Violation tracking
                this.violations = {
                    copyAttempts: 0,
                    pasteAttempts: 0,
                    textSelectionAttempts: 0,
                    tabSwitches: 0,
                    windowFocusLost: 0,
                    suspiciousKeys: 0
                };
                
                // Timing
                this.lastViolationCheck = Date.now();
                this.violationCheckInterval = 2000; // Check every 2 seconds
                
                this.init();
            }
            
            async init() {
                try {
                    console.log('üéØ Initializing Enhanced Proctoring System...');
                    
                    // Initialize MediaPipe Face Detection
                    this.faceDetection = new FaceDetection({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
                    });
                    
                    this.faceDetection.setOptions({
                        model: 'short',
                        minDetectionConfidence: 0.5
                    });
                    
                    this.faceDetection.onResults((results) => this.onFaceDetectionResults(results));
                    
                    // Initialize MediaPipe Face Mesh for pose estimation
                    this.faceMesh = new FaceMesh({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                    });
                    
                    this.faceMesh.setOptions({
                        maxNumFaces: 5,
                        refineLandmarks: true,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    this.faceMesh.onResults((results) => this.onFaceMeshResults(results));
                    
                    // Setup camera and canvas
                    await this.setupCamera();
                    this.setupCanvas();
                    this.setupSecurityListeners();
                    
                    // Start violation monitoring
                    this.startViolationMonitoring();
                    
                    this.isInitialized = true;
                    console.log('‚úÖ Enhanced Proctoring System initialized successfully');
                    
                } catch (error) {
                    console.error('‚ùå Failed to initialize proctoring system:', error);
                    this.updateFaceStatus('Initialization Failed', 'face-warning');
                }
            }
            
            async setupCamera() {
                this.videoElement = document.getElementById('cameraFeed');
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 640,
                            height: 480,
                            frameRate: 30
                        }
                    });
                    
                    this.videoElement.srcObject = stream;
                    this.videoElement.style.display = 'block';
                    
                    // Hide placeholder
                    document.getElementById('cameraPlaceholder').style.display = 'none';
                    document.getElementById('cameraStatus').classList.add('active');
                    
                    // Start camera processing
                    this.camera = new Camera(this.videoElement, {
                        onFrame: async () => {
                            if (this.isInitialized) {
                                await this.faceDetection.send({image: this.videoElement});
                                await this.faceMesh.send({image: this.videoElement});
                            }
                        },
                        width: 640,
                        height: 480
                    });
                    
                    this.camera.start();
                    this.updateFaceStatus('Camera Active', 'face-normal');
                    
                } catch (error) {
                    console.error('‚ùå Camera setup failed:', error);
                    this.updateFaceStatus('Camera Access Denied', 'face-warning');
                    this.cameraBlocked = true;
                }
            }
            
            setupCanvas() {
                this.canvasElement = document.getElementById('faceDetectionCanvas');
                this.canvasCtx = this.canvasElement.getContext('2d');
                
                // Set canvas size to match camera feed
                this.canvasElement.width = 640;
                this.canvasElement.height = 480;
            }
            
            onFaceDetectionResults(results) {
                // Update face count
                this.currentFaceCount = results.detections ? results.detections.length : 0;
                document.getElementById('faceCount').textContent = this.currentFaceCount;
                
                // Clear canvas
                this.canvasCtx.save();
                this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                
                // Draw face detections (like your Python code visualization)
                if (results.detections) {
                    for (const detection of results.detections) {
                        this.drawFaceDetection(detection);
                    }
                }
                
                this.canvasCtx.restore();
                
                // Update status based on face count
                this.updateFaceCountStatus();
            }
            
            onFaceMeshResults(results) {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    // Calculate head pose for first face
                    const landmarks = results.multiFaceLandmarks[0];
                    const pose = this.calculateHeadPose(landmarks);
                    
                    if (pose) {
                        const direction = this.analyzePose(pose.pitch, pose.yaw);
                        const stablePose = this.getStablePose(direction);
                        this.currentPoseDirection = stablePose;
                        
                        // Update display
                        document.getElementById('poseDirection').textContent = 
                            `${stablePose} (Y:${pose.yaw.toFixed(1)})`;
                        
                        // Draw pose information on canvas (like your Python code)
                        this.drawPoseInfo(pose, stablePose);
                    }
                }
            }
            
            calculateHeadPose(landmarks) {
                // Simplified head pose calculation (similar to your Python version)
                // Using key facial landmarks for yaw estimation
                
                const leftEye = landmarks[33];  // Left eye corner
                const rightEye = landmarks[263]; // Right eye corner
                const noseTip = landmarks[1];   // Nose tip
                const chin = landmarks[152];    // Chin
                
                // Calculate yaw angle from eye positions
                const eyeDistance = Math.abs(rightEye.x - leftEye.x);
                const faceCenter = (leftEye.x + rightEye.x) / 2;
                const noseCenterOffset = noseTip.x - faceCenter;
                
                // Estimate yaw angle (simplified calculation)
                const yaw = (noseCenterOffset / eyeDistance) * 60; // Scale factor
                
                // Estimate pitch from nose-chin relationship
                const pitch = (noseTip.y - chin.y) * 90; // Simplified pitch
                
                return { pitch, yaw, roll: 0 };
            }
            
            analyzePose(pitch, yaw) {
                // Only left/right detection as requested (no up/down)
                if (yaw < this.poseThresholds.yawLeft) {
                    return 'left';
                } else if (yaw > this.poseThresholds.yawRight) {
                    return 'right';
                } else {
                    return 'center';
                }
            }
            
            getStablePose(currentPose) {
                // Add to history
                this.poseHistory.push(currentPose);
                if (this.poseHistory.length > this.maxPoseHistory) {
                    this.poseHistory.shift();
                }
                
                // Count occurrences
                const poseCounts = {};
                this.poseHistory.forEach(pose => {
                    poseCounts[pose] = (poseCounts[pose] || 0) + 1;
                });
                
                // Return most common pose if it appears at least 3 times
                const maxCount = Math.max(...Object.values(poseCounts));
                if (maxCount >= 3) {
                    return Object.keys(poseCounts).find(key => poseCounts[key] === maxCount);
                }
                
                return currentPose;
            }
            
            drawFaceDetection(detection) {
                // Draw bounding box (like your Python code)
                const bbox = detection.boundingBox;
                const x = bbox.xCenter * this.canvasElement.width - (bbox.width * this.canvasElement.width) / 2;
                const y = bbox.yCenter * this.canvasElement.height - (bbox.height * this.canvasElement.height) / 2;
                const width = bbox.width * this.canvasElement.width;
                const height = bbox.height * this.canvasElement.height;
                
                this.canvasCtx.strokeStyle = '#00ff00';
                this.canvasCtx.lineWidth = 2;
                this.canvasCtx.strokeRect(x, y, width, height);
                
                // Draw keypoints
                if (detection.landmarks) {
                    this.canvasCtx.fillStyle = '#ff0000';
                    for (const landmark of detection.landmarks) {
                        const x = landmark.x * this.canvasElement.width;
                        const y = landmark.y * this.canvasElement.height;
                        this.canvasCtx.beginPath();
                        this.canvasCtx.arc(x, y, 3, 0, 2 * Math.PI);
                        this.canvasCtx.fill();
                    }
                }
            }
            
            drawPoseInfo(pose, direction) {
                // Draw pose text (like your Python code)
                this.canvasCtx.fillStyle = '#00ff00';
                this.canvasCtx.font = '16px monospace';
                this.canvasCtx.fillText(
                    `Pose: ${direction} (Y:${pose.yaw.toFixed(1)})`, 
                    10, 30
                );
            }
            
            updateFaceCountStatus() {
                const statusElement = document.getElementById('faceStatus');
                
                if (this.currentFaceCount === 0 || this.cameraBlocked) {
                    this.updateFaceStatus('WARNING: No face detected!', 'face-warning');
                    // Show immediate popup for no face detection
                    this.showViolationAlert('‚ö†Ô∏è NO FACE DETECTED!');
                    // IMMEDIATELY SEND TO BACKEND FOR COUNTING
                    this.sendImmediateViolation('NO_FACE');
                } else if (this.currentFaceCount > 1) {
                    this.updateFaceStatus(`WARNING: ${this.currentFaceCount} faces detected!`, 'face-warning');
                    // Show immediate popup for multiple faces
                    this.showViolationAlert(`‚ö†Ô∏è ${this.currentFaceCount} FACES DETECTED!`);
                    // IMMEDIATELY SEND TO BACKEND FOR COUNTING
                    this.sendImmediateViolation('MULTIPLE_FACES');
                } else if (this.currentPoseDirection === 'left' || this.currentPoseDirection === 'right') {
                    this.updateFaceStatus(`WARNING: Looking ${this.currentPoseDirection}!`, 'face-warning');
                    // Show immediate popup for looking away
                    this.showViolationAlert(`‚ö†Ô∏è LOOKING ${this.currentPoseDirection.toUpperCase()}!`);
                    // IMMEDIATELY SEND TO BACKEND FOR COUNTING - MOST IMPORTANT
                    this.sendImmediateViolation('LOOKING_AWAY');
                } else {
                    this.updateFaceStatus('Normal', 'face-normal');
                }
            }
            
            updateFaceStatus(text, className) {
                const statusElement = document.getElementById('faceStatus');
                statusElement.textContent = text;
                statusElement.className = className;
            }
            
            setupSecurityListeners() {
                // Disable right-click context menu
                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.violations.suspiciousKeys++;
                    return false;
                });
                
                // Block copy/paste operations
                document.addEventListener('keydown', (e) => {
                    // Block Ctrl+C, Ctrl+V, Ctrl+A, Ctrl+X, etc.
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key.toLowerCase()) {
                                                                                     case 'c':
                                e.preventDefault();
                                this.violations.copyAttempts++;
                                this.showViolationAlert('üö´ COPY BLOCKED!');
                                this.sendImmediateViolation('COPY_ATTEMPT');
                                break;
                            case 'v':
                                e.preventDefault();
                                this.violations.pasteAttempts++;
                                this.showViolationAlert('üö´ PASTE BLOCKED!');
                                this.sendImmediateViolation('PASTE_ATTEMPT');
                                break;
                            case 'x':
                                e.preventDefault();
                                this.violations.copyAttempts++;
                                this.showViolationAlert('üö´ CUT BLOCKED!');
                                this.sendImmediateViolation('CUT_ATTEMPT');
                                break;
                            case 'a':
                                // Allow Ctrl+A only in answer inputs
                                if (!e.target.matches('textarea, input[type="text"]')) {
                                    e.preventDefault();
                                    this.violations.textSelectionAttempts++;
                                }
                                break;
                            case 'f':
                            case 'h':
                            case 'r':
                            case 'u':
                            case 'i':
                            case 'j':
                            case 's':
                                e.preventDefault();
                                this.violations.suspiciousKeys++;
                                                                 this.showViolationAlert('üö´ BROWSER FUNCTION BLOCKED!');
                                break;
                        }
                    }
                    
                    // Block F12, F11, and other function keys
                    if (e.key.startsWith('F') && ['F11', 'F12'].includes(e.key)) {
                        e.preventDefault();
                        this.violations.suspiciousKeys++;
                                                 this.showViolationAlert('üö´ DEVELOPER TOOLS BLOCKED!');
                    }
                });
                
                // Detect tab switching and window focus
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.violations.tabSwitches++;
                        this.showViolationAlert('üö® TAB SWITCH DETECTED!');
                        this.sendImmediateViolation('TAB_SWITCH');
                        console.log('üö® Tab switch detected!');
                    }
                });
                
                window.addEventListener('blur', () => {
                    this.violations.windowFocusLost++;
                    this.showViolationAlert('üö® WINDOW FOCUS LOST!');
                    this.sendImmediateViolation('WINDOW_FOCUS');
                    console.log('üö® Window focus lost!');
                });
                
                // Block text selection except in answer inputs
                document.addEventListener('selectstart', (e) => {
                    if (!e.target.matches('textarea, input[type="text"]')) {
                        e.preventDefault();
                        this.violations.textSelectionAttempts++;
                        this.showViolationAlert('üö® TEXT SELECTION BLOCKED!');
                        this.sendImmediateViolation('TEXT_SELECTION');
                        return false;
                    }
                });
            }
            
            showViolationAlert(message, warningCount = null) {
                // Show RAPID 2-second popup for violations
                const alertElement = document.createElement('div');
                alertElement.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #ff4757;
                    color: white;
                    padding: 20px 30px;
                    border-radius: 10px;
                    z-index: 99999;
                    font-weight: bold;
                    font-size: 18px;
                    box-shadow: 0 8px 16px rgba(0,0,0,0.4);
                    border: 3px solid #ff3838;
                    text-align: center;
                    min-width: 400px;
                    animation: violationPulse 0.5s ease-in-out;
                `;
                
                // Add warning count if provided
                const warningText = warningCount ? `Warning ${warningCount}/20` : '';
                alertElement.innerHTML = `
                    <div style="font-size: 16px; margin-bottom: 8px; color: #ffecec;">${warningText}</div>
                    <div style="font-size: 20px; font-weight: bold;">${message}</div>
                    <div style="font-size: 14px; margin-top: 8px; opacity: 0.9;">This popup will close in 2 seconds</div>
                `;
                
                document.body.appendChild(alertElement);
                
                // Add CSS animation if not exists
                if (!document.getElementById('violationStyles')) {
                    const style = document.createElement('style');
                    style.id = 'violationStyles';
                    style.textContent = `
                        @keyframes violationPulse {
                            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                            50% { transform: translate(-50%, -50%) scale(1.05); }
                            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Remove after EXACTLY 2 seconds
                setTimeout(() => {
                    if (alertElement.parentNode) {
                        alertElement.style.opacity = '0';
                        alertElement.style.transform = 'translate(-50%, -50%) scale(0.8)';
                        setTimeout(() => {
                            if (alertElement.parentNode) {
                                alertElement.parentNode.removeChild(alertElement);
                            }
                        }, 200);
                    }
                }, 2000);
            }
            
            startViolationMonitoring() {
                setInterval(() => {
                    this.checkAndReportViolations();
                }, this.violationCheckInterval);
            }
            
            // CRITICAL FUNCTION: Send violation immediately for counting (with rate limiting)
            async sendImmediateViolation(violationType) {
                try {
                    // RATE LIMITING: Check if enough time has passed since last violation of this type
                    const currentTime = Date.now();
                    const lastTime = this.lastViolationTime ? this.lastViolationTime[violationType] || 0 : 0;
                    const timeSinceLastViolation = currentTime - lastTime;
                    
                    if (timeSinceLastViolation < 4000) { // 4 second cooldown
                        console.log(`‚è≥ RATE LIMITED: ${violationType} (${timeSinceLastViolation}ms since last)`);
                        return; // Skip this violation
                    }
                    
                    // Update last violation time
                    if (!this.lastViolationTime) this.lastViolationTime = {};
                    this.lastViolationTime[violationType] = currentTime;
                    
                    console.log('üö® IMMEDIATE VIOLATION:', violationType);
                    
                    // Prepare violation data based on current state
                    const violationData = {
                        faceData: {
                            numFaces: this.currentFaceCount,
                            poseDirection: this.currentPoseDirection,
                            cameraBlocked: this.cameraBlocked
                        },
                        browserData: {
                            tabSwitched: false,
                            windowFocusLost: false
                        },
                        inputData: {
                            copyAttempt: false,
                            pasteAttempt: false,
                            textSelectionAttempt: false,
                            suspiciousKeys: false
                        },
                        violationType: violationType,
                        immediate: true
                    };
                    
                    console.log('üì§ SENDING IMMEDIATE VIOLATION:', violationData);
                    
                    const response = await fetch(`/student/exam/{{ exam.id }}/procrastination-check`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                        },
                        body: JSON.stringify(violationData)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('‚úÖ IMMEDIATE VIOLATION RESPONSE:', result);
                        
                        // Update warning counter immediately
                        if (result.warningCount !== undefined) {
                            console.log('üî¢ UPDATING COUNTER TO:', result.warningCount);
                            updateWarningCounter(result.warningCount);
                            playWarningBeep();
                        }
                        
                        // Handle auto-submit (preserve existing functionality)
                        if (result.autoSubmit) {
                            this.showViolationAlert('MAXIMUM VIOLATIONS REACHED!', result.warningCount);
                            setTimeout(() => {
                                alert(result.autoSubmitMessage || 'Maximum violations reached. Exam will be auto-submitted.');
                                // Use existing submit functionality without breaking it
                                const submitBtn = document.getElementById('submitExamBtn');
                                if (submitBtn) {
                                    submitBtn.click(); // Use existing submit button
                 } else {
                                    // Fallback: trigger form submission
                                    const examForm = document.getElementById('examForm');
                                    if (examForm) {
                                        examForm.submit();
                                    }
                                }
                            }, 2000);
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error sending immediate violation:', error);
                }
            }
            
            async checkAndReportViolations() {
                try {
                    // Count ACTIVE violations
                    let activeViolations = 0;
                    
                    // Face detection violations
                    const faceViolations = {
                        noFace: this.currentFaceCount === 0 || this.cameraBlocked,
                        multipleFaces: this.currentFaceCount > 1,
                        lookingAway: this.currentPoseDirection === 'left' || this.currentPoseDirection === 'right'
                    };
                    
                    // Count face violations
                    if (faceViolations.noFace) activeViolations++;
                    if (faceViolations.multipleFaces) activeViolations++;
                    if (faceViolations.lookingAway) activeViolations++;
                    
                    // Add browser/input violations
                    activeViolations += this.violations.tabSwitches;
                    activeViolations += this.violations.windowFocusLost;
                    activeViolations += this.violations.copyAttempts;
                    activeViolations += this.violations.pasteAttempts;
                    activeViolations += this.violations.textSelectionAttempts;
                    activeViolations += this.violations.suspiciousKeys;
                    
                    const violationData = {
                        faceData: {
                            numFaces: this.currentFaceCount,
                            poseDirection: this.currentPoseDirection,
                            cameraBlocked: this.cameraBlocked
                        },
                        browserData: {
                            tabSwitched: this.violations.tabSwitches > 0,
                            windowFocusLost: this.violations.windowFocusLost > 0
                        },
                        inputData: {
                            copyAttempt: this.violations.copyAttempts > 0,
                            pasteAttempt: this.violations.pasteAttempts > 0,
                            textSelectionAttempt: this.violations.textSelectionAttempts > 0,
                            suspiciousKeys: this.violations.suspiciousKeys > 0
                        },
                        totalViolations: activeViolations
                    };
                    
                    // Send if there are ANY violations
                    const hasViolations = activeViolations > 0;
                    
                    if (hasViolations) {
                        console.log('üö® SENDING VIOLATION DATA TO BACKEND:', violationData);
                        console.log('üö® Total violations being sent:', activeViolations);
                        
                        const response = await fetch(`/student/exam/{{ exam.id }}/procrastination-check`, {
                         method: 'POST',
                         headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
                            },
                            body: JSON.stringify(violationData)
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            
                            // Update warning counter - CRITICAL FIX
                            if (result.warningCount !== undefined) {
                                console.log('üî¢ Backend returned warning count:', result.warningCount);
                                updateWarningCounter(result.warningCount);
                                
                                // Play warning beep sound
                                playWarningBeep();
                    } else {
                                console.error('‚ùå No warningCount in response!', result);
                            }
                            
                                                         // Handle auto-submit
                             if (result.autoSubmit) {
                                 // Show final warning popup
                                 this.showViolationAlert('MAXIMUM VIOLATIONS REACHED!', result.warningCount);
                                 
                                 // Wait 2 seconds then auto-submit
                                 setTimeout(() => {
                                     alert(result.autoSubmitMessage || 'Maximum violations reached. Exam will be auto-submitted.');
                                     // Trigger auto-submit based on exam type
                                     if ('{{ exam.exam_format }}' === 'objective') {
                                         submitExam(); // Use existing objective submit function
                                     } else {
                                         submitExamWithAnswers(); // Use existing subjective submit function
                                     }
                                 }, 2000);
                                 return;
                             }
                             
                             // Show warning alert with count
                             if (result.alertMessage) {
                                 this.showViolationAlert(result.alertMessage, result.warningCount);
                             }
                             
                             // Show specific violation alerts for immediate feedback
                             if (result.violations && result.violations.length > 0) {
                                 result.violations.forEach(violation => {
                                     if (violation.severity === 'HIGH' || violation.severity === 'CRITICAL') {
                                         setTimeout(() => {
                                             this.showViolationAlert(violation.message, result.warningCount);
                                         }, 100);
                                     }
                                 });
                             }
                        }
                    }
                    
                    // Reset violation counters
                    Object.keys(this.violations).forEach(key => {
                        this.violations[key] = 0;
                    });
                    
                } catch (error) {
                    console.error('Error reporting violations:', error);
                }
            }
        }
        
        // Initialize Enhanced Proctoring System
        let enhancedProctoring;
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Initializing Enhanced Proctoring System...');
            enhancedProctoring = new EnhancedProctoringSystem();
            
            // Auto-save and question marking are already initialized in main DOMContentLoaded
            // No need to duplicate here
            
            console.log('‚úÖ Enhanced Proctoring System initialized');
        });
        
        // VIOLATION COUNTER UPDATE FUNCTION - OUR OWN SYSTEM
        function updateWarningCounter(count) {
            console.log('üî¢ Updating violation counter to:', count);
            const violationBadge = document.getElementById('violation-badge');
            if (violationBadge) {
                violationBadge.textContent = `${count}/20`;
                // Color coding: Green (0-9), Yellow (10-14), Red (15-20)
                if (count >= 15) {
                    violationBadge.className = 'badge bg-danger';
                } else if (count >= 10) {
                    violationBadge.className = 'badge bg-warning';
                } else {
                    violationBadge.className = 'badge bg-success';
                }
                console.log('‚úÖ Violation counter updated successfully to:', count);
                
                // Flash effect on update
                violationBadge.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    violationBadge.style.transform = 'scale(1)';
                }, 200);
                
            } else {
                console.error('‚ùå Violation counter element not found!');
            }
        }
        
        // WARNING BEEP SOUND FUNCTION
        function playWarningBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Warning beep sound (800Hz for 0.3 seconds)
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
                
                console.log('üîä Warning beep played');
            } catch (e) {
                console.log('üîá Audio not available:', e.message);
            }
                }



        // Clean functions without debugging
        
        function markAnsweredQuestions() {
            const savedAnswers = {{ saved_answers|tojson }};
            console.log('Marking answered questions with saved answers:', savedAnswers);
            
            // Create mapping between question IDs and question numbers
            const questionIdToNumber = {};
            {% for question in questions %}
            questionIdToNumber['{{ question._id or question.id }}'] = {{ loop.index }};
            {% endfor %}
            
            // Check each question for saved answers
            Object.keys(savedAnswers).forEach(function(answerKey) {
                if (savedAnswers[answerKey]) {
                    let questionId = answerKey;
                    // Handle both formats: 'answer_123' and '123'
                    if (answerKey.startsWith('answer_')) {
                        questionId = answerKey.replace('answer_', '');
                    }
                    const questionNumber = questionIdToNumber[questionId];
                    
                    if (questionNumber) {
                        // Mark the navigation button as answered
                        const questionBtn = document.querySelector(`[data-question="${questionNumber}"]`);
                        if (questionBtn) {
                            questionBtn.classList.add('answered', 'saved');
                            console.log(`Marked question ${questionNumber} as answered and saved`);
                        }
                        
                        // Find the question input by name for additional processing
                        const inputName = answerKey.startsWith('answer_') ? answerKey : `answer_${answerKey}`;
                        const questionInput = document.querySelector(`[name="${inputName}"]`);
                        if (questionInput && questionInput.type === 'radio') {
                            const radioButtons = document.querySelectorAll(`[name="${inputName}"]`);
                            radioButtons.forEach(function(radio) {
                                if (radio.value === savedAnswers[answerKey]) {
                                    radio.checked = true;
                                    // Also mark the option visually
                                    const optionItem = radio.closest('.option-item');
                                    if (optionItem) {
                                        optionItem.classList.add('selected');
                                    }
                                }
                            });
                        }
                    }
                }
            });
        }
        
        // Visual feedback functions for answer saving
        function markQuestionAsSaved(questionNumber) {
            // Find the question navigation button using question number
            const questionBtn = document.querySelector(`[data-question="${questionNumber}"]`);
            if (questionBtn) {
                // Add saved class for green styling
                questionBtn.classList.add('answered', 'saved');
                
                // Add a brief animation
                questionBtn.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    questionBtn.style.transform = '';
                }, 200);
                
                console.log(`Question ${questionNumber} marked as saved`);
            } else {
                console.log(`Question button not found for question ${questionNumber}`);
            }
        }
        
        function showSaveConfirmation(questionNumber) {
            // Create a small save indicator
            const saveIndicator = document.createElement('div');
            saveIndicator.className = 'save-indicator';
            saveIndicator.innerHTML = `<i class="fas fa-check-circle"></i> Question ${questionNumber} Saved`;
            saveIndicator.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 8px 15px;
                border-radius: 20px;
                font-size: 0.85rem;
                z-index: 1000;
                opacity: 0;
                transform: translateX(100px);
                transition: all 0.3s ease;
                box-shadow: 0 2px 10px rgba(40, 167, 69, 0.3);
            `;
            
            document.body.appendChild(saveIndicator);
            
            // Animate in
            setTimeout(() => {
                saveIndicator.style.opacity = '1';
                saveIndicator.style.transform = 'translateX(0)';
            }, 10);
            
            // Animate out and remove
            setTimeout(() => {
                saveIndicator.style.opacity = '0';
                saveIndicator.style.transform = 'translateX(100px)';
                setTimeout(() => {
                    if (saveIndicator.parentNode) {
                        saveIndicator.remove();
                    }
                }, 300);
            }, 2000);
        }

        // Helper function to reset save button
        function resetSaveButton(saveBtn, questionNumber) {
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save me-1"></i> Save & Next';
            }
        }
        
        // Save current answer without navigating (for last question)
        function saveCurrentAnswer(currentQuestionNumber) {
            const examId = '{{ exam.id }}';
            
            // Show immediate feedback
            const saveBtn = document.getElementById(`saveBtn-${currentQuestionNumber}`);
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Saving...';
            }
            
            // Get current question's answer
            const questionContainer = document.getElementById(`question-container-${currentQuestionNumber}`);
            if (!questionContainer) {
                resetCurrentSaveButton(saveBtn, currentQuestionNumber);
                return;
            }
            
            // Find the input/textarea for this question
            const answerInput = questionContainer.querySelector('input[name^="answer_"]:checked') || 
                              questionContainer.querySelector('textarea[name^="answer_"]') || 
                              questionContainer.querySelector('select[name^="answer_"]');
            
            console.log('üîç CURRENT SAVE DEBUG - Question container:', questionContainer);
            console.log('üîç CURRENT SAVE DEBUG - Answer input found:', answerInput);
            
            if (!answerInput) {
                console.log('üîç CURRENT SAVE DEBUG - No answer input found in container');
                showAlert('warning', 'Please provide an answer before saving.');
                resetCurrentSaveButton(saveBtn, currentQuestionNumber);
                return;
            }
            
            const questionId = answerInput.name.replace('answer_', '');
            console.log('üîç CURRENT SAVE DEBUG - Input name:', answerInput.name, 'Question ID:', questionId);
            const answer = answerInput.type === 'radio' || answerInput.type === 'checkbox' ? 
                (answerInput.checked ? answerInput.value : '') : answerInput.value;
            
            if (!answer || answer.trim() === '') {
                showAlert('warning', 'Please provide an answer before saving.');
                resetCurrentSaveButton(saveBtn, currentQuestionNumber);
                return;
            }
            
            // Save the answer
            fetch('/student/exam/' + examId + '/save-answer', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    question_id: questionId,
                    answer: answer
                }),
                signal: AbortSignal.timeout(5000) // 5 second timeout
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Mark question as saved
                        markQuestionAsSaved(currentQuestionNumber);
                        
                    // Show save confirmation
                        showSaveConfirmation(currentQuestionNumber);
                        
                    // Show success message
                    showAlert('success', `Question ${currentQuestionNumber} saved successfully!`);
                    } else {
                        throw new Error(data.message || 'Save failed');
                    }
                })
                .catch(error => {
                    console.error('Save error:', error);
                    
                    if (error.name === 'TimeoutError') {
                    showAlert('warning', 'Save timeout. Answer may have been saved.');
                    } else {
                        showAlert('error', 'Error saving answer. Please try again.');
                    }
                })
                .finally(() => {
                resetCurrentSaveButton(saveBtn, currentQuestionNumber);
                });
        }
        
        // Helper function to reset current save button
        function resetCurrentSaveButton(saveBtn, questionNumber) {
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = '<i class="fas fa-save me-1"></i> Save Answer';
            }
        }
        
        // SIMPLIFIED AND WORKING Save and Next functionality
        function saveAndNext(currentQuestionNumber) {
            console.log('üöÄ Save & Next called for question:', currentQuestionNumber);
            
            const examId = '{{ exam.id }}';
            
            // Show loading state
            const saveBtn = document.getElementById(`saveNextBtn-${currentQuestionNumber}`);
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Saving...';
            }
            
            // Get current question's answer
            const questionContainer = document.getElementById(`question-container-${currentQuestionNumber}`);
            if (!questionContainer) {
                console.error('‚ùå Question container not found');
                resetSaveButton(saveBtn, currentQuestionNumber);
                return;
            }
            
            // Find answer input - try all types
            let answerInput = null;
            let answer = '';
            
            // Try radio buttons first (for MCQ)
            const radioInputs = questionContainer.querySelectorAll('input[type="radio"]:checked');
            if (radioInputs.length > 0) {
                answerInput = radioInputs[0];
                answer = answerInput.value;
            }
            
            // Try textarea (for subjective)
            if (!answerInput) {
                const textareas = questionContainer.querySelectorAll('textarea[name^="answer_"]');
                if (textareas.length > 0) {
                    answerInput = textareas[0];
                    answer = answerInput.value.trim();
                }
            }
            
            // Try text inputs
            if (!answerInput) {
                const textInputs = questionContainer.querySelectorAll('input[type="text"][name^="answer_"]');
                if (textInputs.length > 0) {
                    answerInput = textInputs[0];
                    answer = answerInput.value.trim();
                }
            }
            
            console.log('üìù Found answer input:', answerInput);
            console.log('üìù Answer value:', answer);
            
            if (!answerInput) {
                console.error('‚ùå No answer input found');
                showAlert('warning', 'Please provide an answer before proceeding.');
                resetSaveButton(saveBtn, currentQuestionNumber);
                return;
            }
            
            if (!answer || answer === '') {
                console.error('‚ùå Empty answer');
                showAlert('warning', 'Please provide an answer before proceeding.');
                resetSaveButton(saveBtn, currentQuestionNumber);
                return;
            }
            
            // Extract question ID from input name
            const questionId = answerInput.name.replace('answer_', '');
            console.log('üîç Question ID:', questionId);
            
            // Save the answer
            fetch('/student/exam/' + examId + '/save-answer', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    question_id: questionId,
                    answer: answer
                })
            })
            .then(response => {
                console.log('üì° Save response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('üì° Save response data:', data);
                
                if (data.success) {
                    console.log('‚úÖ Save successful');
                    
                    // Mark question as saved (green checkmark)
                    markQuestionAsSaved(currentQuestionNumber);
                    
                    // Show save confirmation
                    showSaveConfirmation(currentQuestionNumber);
                    
                    // Navigate to next question after short delay
                    setTimeout(() => {
                        console.log('üîÑ Navigating to next question:', currentQuestionNumber + 1);
                        navigateToQuestion(currentQuestionNumber + 1);
                    }, 500);
                } else {
                    console.error('‚ùå Save failed:', data.message);
                    showAlert('error', 'Error saving answer: ' + data.message);
                }
            })
            .catch(error => {
                console.error('‚ùå Save error:', error);
                showAlert('error', 'Error saving answer. Please try again.');
            })
            .finally(() => {
                resetSaveButton(saveBtn, currentQuestionNumber);
            });
        }
        
        // SIMPLIFIED Auto-save functionality
        function initializeAutoSave() {
            console.log('üöÄ Initializing simplified auto-save...');
            
            const examId = '{{ exam.id }}';
            const inputs = document.querySelectorAll('input[name^="answer_"], textarea[name^="answer_"], select[name^="answer_"]');
            
            console.log('üìù Found', inputs.length, 'input elements for auto-save');
            
            // Create mapping between question IDs and question numbers
            const questionIdToNumber = {};
            {% for question in questions %}
            questionIdToNumber['{{ question._id or question.id }}'] = {{ loop.index }};
            {% endfor %}
            
            console.log('üó∫Ô∏è Question ID to Number mapping:', questionIdToNumber);
            
            inputs.forEach(function(input) {
                const questionId = input.name.replace('answer_', '');
                const questionNumber = questionIdToNumber[questionId];
                
                console.log('üîó Setting up auto-save for input:', input.name, 'Question #:', questionNumber);
                
                // Debounced save function
                const saveAnswer = debounce(function() {
                    let answer = '';
                    
                    if (input.type === 'radio' || input.type === 'checkbox') {
                        if (input.checked) {
                            answer = input.value;
                } else {
                            return; // Don't save unchecked radio/checkbox
                        }
                    } else {
                        answer = input.value.trim();
                    }
                    
                    if (answer !== '') {
                        console.log('üíæ Auto-saving question', questionNumber, 'with answer:', answer);
                        
                        fetch('/student/exam/' + examId + '/save-answer', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                question_id: questionId,
                                answer: answer
                            })
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.success && questionNumber) {
                                console.log('‚úÖ Auto-save successful for question', questionNumber);
                                markQuestionAsSaved(questionNumber);
                                showSaveConfirmation(questionNumber);
                            } else {
                                console.log('‚ùå Auto-save failed:', data);
                            }
                        })
                        .catch(error => {
                            console.error('‚ùå Auto-save error:', error);
                        });
                    }
                }, 1000); // 1 second delay
                
                // Add event listeners
                if (input.type === 'radio' || input.type === 'checkbox') {
                    input.addEventListener('change', saveAnswer);
                } else {
                    input.addEventListener('input', saveAnswer);
                    input.addEventListener('change', saveAnswer);
                }
            });
        }
</script>

    <!-- MediaPipe Face Detection Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
</body>
</html> 